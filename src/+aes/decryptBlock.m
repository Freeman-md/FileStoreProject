function decryptedBlock = decryptBlock(cipherBlockBytes, roundKeys)
%AES.DECRYPTBLOCK AES-128 block decryption (one 16-byte block).
%
%   decryptedBlock = aes.decryptBlock(cipherBlockBytes, roundKeys)
%
%   cipherBlockBytes must be a 16-byte uint8 vector.
%   roundKeys is the 4×44 uint8 matrix generated by aes.keyExpansion.

    if ~isa(cipherBlockBytes, 'uint8') || numel(cipherBlockBytes) ~= 16
        error('decryptBlock:InvalidBlock', ...
              'AES block must be exactly 16 bytes (uint8).');
    end

    % reshape into 4×4 state matrix
    state = reshape(cipherBlockBytes, 4, []);

    % AES parameters
    Nr = 10;

    % Initial AddRoundKey (last round key)
    keyStart = Nr * 4 + 1;
    state = addRoundKey(state, roundKeys(:, keyStart:keyStart+3));

    % Main inverse rounds (9 rounds)
    for roundIndex = (Nr-1):-1:1
        state = invShiftRows(state);
        state = invSubBytes(state);

        keyStart = roundIndex * 4 + 1;
        state = addRoundKey(state, roundKeys(:, keyStart:keyStart+3));

        state = invMixColumns(state);
    end

    % Final inverse round (no InvMixColumns)
    state = invShiftRows(state);
    state = invSubBytes(state);
    state = addRoundKey(state, roundKeys(:, 1:4));

    decryptedBlock = reshape(state, 1, 16);
end


% Inverse helper functions

function out = addRoundKey(state, keyWords)
    out = bitxor(state, keyWords);
end

function out = invShiftRows(state)
    out = state;
    out(2, :) = circshift(out(2, :), [0 1]);
    out(3, :) = circshift(out(3, :), [0 2]);
    out(4, :) = circshift(out(4, :), [0 3]);
end

function out = invSubBytes(state)
    out = uint8(aes_inv_sbox_lookup(double(state) + 1));
end

function out = invMixColumns(state)
    out = zeros(4,4,'uint8');
    for col = 1:4
        s = state(:,col);
        out(1,col) = bitxor(bitxor(bitxor(mult(s(1),14), mult(s(2),11)), mult(s(3),13)), mult(s(4),9));
        out(2,col) = bitxor(bitxor(bitxor(mult(s(1),9),  mult(s(2),14)), mult(s(3),11)), mult(s(4),13));
        out(3,col) = bitxor(bitxor(bitxor(mult(s(1),13), mult(s(2),9)),  mult(s(3),14)), mult(s(4),11));
        out(4,col) = bitxor(bitxor(bitxor(mult(s(1),11), mult(s(2),13)), mult(s(3),9)),  mult(s(4),14));
    end
end

function y = mult(x, c)
    switch c
        case 9
            y = bitxor(aes_xtime(aes_xtime(aes_xtime(x))), x);
        case 11
            y = bitxor(bitxor(aes_xtime(aes_xtime(aes_xtime(x))), aes_xtime(x)), x);
        case 13
            y = bitxor(bitxor(aes_xtime(aes_xtime(aes_xtime(x))), aes_xtime(aes_xtime(x))), x);
        case 14
            y = bitxor(bitxor(aes_xtime(aes_xtime(aes_xtime(x))), aes_xtime(aes_xtime(x))), aes_xtime(x));
        otherwise
            error('invalid c');
    end
end

function out = aes_inv_sbox_lookup(indices)
    persistent invS
    if isempty(invS)
        hexTable = [
            '52096ad53036a538bf40a39e81f3d7fb';
            '7ce339829b2fff87348e4344c4dee9cb';
            '547b9432a6c2233dee4c950b42fac34e';
            '082ea16628d924b2765ba2496d8bd125';
            '72f8f66486689816d4a45ccc5d65b692';
            '6c704850fdedb9da5e154657a78d9d84';
            '90d8ab008cbcd30af7e45805b8b34506';
            'd02c1e8fca3f0f02c1afbd0301138a6b';
            '3a9111414f67dcea97f2cfcef0b4e673';
            '96ac7422e7ad3585e2f937e81c75df6e';
            '47f11a711d29c5896fb7620eaa18be1b';
            'fc563e4bc6d279209adbc0fe78cd5af4';
            '1fdda8338807c731b11210592780ec5f';
            '60517fa919b54a0d2de57a9f93c99cef';
            'a0e03b4dae2af5b0c8ebbb3c83539961';
            '172b047eba77d626e169146355210c7d'
        ];

        % CONVERT: 16 rows × 32 chars → 512 chars → 256 byte pairs
        chars = hexTable.';      % => 32 × 16
        chars = chars(:).';      % => 1 × 512
        bytePairs = reshape(chars, 2, []).';   % => 256 × 2

        invS = uint8(hex2dec(bytePairs));      % => 256 × 1
    end

    out = invS(indices);
end


function out = aes_xtime(x)
    out = bitshift(x,1);
    if bitget(x,8)
        out = bitxor(out, 27);
    end
    out = bitand(out,255);
end
