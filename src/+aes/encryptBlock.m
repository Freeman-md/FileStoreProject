function encryptedBlock = encryptBlock(inputBlockBytes, roundKeys)
%AES.ENCRYPTBLOCK AES-128 block encryption (one 16-byte block).
%
%   encryptedBlock = aes.encryptBlock(inputBlockBytes, roundKeys)
%
%   inputBlockBytes must be a 16-byte uint8 vector.
%   roundKeys is the 4×44 uint8 matrix generated by aes.keyExpansion.

    if ~isa(inputBlockBytes, 'uint8') || numel(inputBlockBytes) ~= 16
        error('encryptBlock:InvalidBlock', ...
              'AES block must be exactly 16 bytes (uint8).');
    end

    % reshape into 4×4 state matrix
    state = reshape(inputBlockBytes, 4, []);

    % AES parameters
    Nr = 10;  % number of rounds for AES-128

    % Initial AddRoundKey
    state = addRoundKey(state, roundKeys(:, 1:4));

    % Main rounds (1 -> 9)
    for roundIndex = 1:(Nr - 1)
        state = subBytes(state);
        state = shiftRows(state);
        state = mixColumns(state);
        keyStart = roundIndex * 4 + 1;
        state = addRoundKey(state, roundKeys(:, keyStart:keyStart+3));
    end

    % Final round (no MixColumns)
    state = subBytes(state);
    state = shiftRows(state);
    keyStart = Nr * 4 + 1;
    state = addRoundKey(state, roundKeys(:, keyStart:keyStart+3));

    encryptedBlock = reshape(state, 1, 16);
end


% helper functions

function out = addRoundKey(state, keyWords)
    out = bitxor(state, keyWords);
end

function out = subBytes(state)
    out = uint8(aes_sbox_lookup(double(state) + 1));
end

function out = shiftRows(state)
    out = state;
    out(2, :) = circshift(out(2, :), [0 -1]);
    out(3, :) = circshift(out(3, :), [0 -2]);
    out(4, :) = circshift(out(4, :), [0 -3]);
end

function out = mixColumns(state)
    out = zeros(4,4,'uint8');
    for col = 1:4
        a = state(:,col);
        out(:,col) = [ ...
            bitxor(bitxor(bitxor(xt(a(1),2), xt(a(2),3)), a(3)), a(4)); ...
            bitxor(bitxor(bitxor(xt(a(2),2), xt(a(3),3)), a(1)), a(4)); ...
            bitxor(bitxor(bitxor(xt(a(3),2), xt(a(4),3)), a(1)), a(2)); ...
            bitxor(bitxor(bitxor(xt(a(4),2), xt(a(1),3)), a(2)), a(3))  ...
        ];
    end
end

function y = xt(x, m)
    if m == 2
        y = aes_xtime(x);
    elseif m == 3
        y = bitxor(aes_xtime(x), x);
    else
        error('xtime:InvalidMultiplier','AES MixColumns uses only multipliers 2 or 3.');
    end
end

function out = aes_sbox_lookup(indices)
    persistent S
    if isempty(S)
        S = uint8([
        99 124 119 123 242 107 111 197  48   1 103  43 254 215 171 118 ...
        202 130 201 125 250  89  71 240 173 212 162 175 156 164 114 192 ...
        183 253 147  38  54  63 247 204  52 165 229 241 113 216  49  21 ...
          4 199  35 195  24 150   5 154   7  18 128 226 235  39 178 117 ...
          9 131  44  26  27 110  90 160  82  59 214 179  41 227  47 132 ...
        83 209   0 237  32 252 177  91 106 203 190  57  74  76  88 207 ...
        208 239 170 251  67  77  51 133  69 249   2 127  80  60 159 168 ...
         81 163  64 143 146 157  56 245 188 182 218  33  16 255 243 210 ...
        205  12  19 236  95 151  68  23 196 167 126  61 100  93  25 115 ...
         96 129  79 220  34  42 144 136  70 238 184  20 222  94  11 219 ...
        224  50  58  10  73   6  36  92 194 211 172  98 145 149 228 121 ...
        231 200  55 109 141 213  78 169 108  86 244 234 101 122 174   8 ...
        186 120  37  46  28 166 180 198 232 221 116  31  75 189 139 138 ...
        112  62 181 102  72   3 246  14  97  53  87 185 134 193  29 158 ...
        225 248 152  17 105 217 142 148 155  30 135 233 206  85  40 223 ...
        140 161 137  13 191 230  66 104  65 153  45  15 176  84 187  22]);
    end
    out = S(indices);
end

function out = aes_xtime(x)
    out = bitshift(x,1);
    if bitget(x,8)
        out = bitxor(out, 27);
    end
    out = bitand(out,255);
end
