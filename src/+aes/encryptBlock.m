function encryptedBlock = encryptBlock(inputBlockBytes, roundKeys)
%AES.ENCRYPTBLOCK AES-128 block encryption (one 16-byte block).
%
%   encryptedBlock = aes.encryptBlock(inputBlockBytes, roundKeys)
%
%   inputBlockBytes must be a 16-byte uint8 vector.
%   roundKeys is the 4×44 uint8 matrix generated by aes.keyExpansion.

    if ~isa(inputBlockBytes, 'uint8') || numel(inputBlockBytes) ~= 16
        error('encryptBlock:InvalidBlock', ...
              'AES block must be exactly 16 bytes (uint8).');
    end

    % reshape into 4×4 state matrix
    state = reshape(inputBlockBytes, 4, []);

    % AES parameters
    Nr = 10;  % number of rounds for AES-128

    % Initial AddRoundKey
    state = addRoundKey(state, roundKeys(:, 1:4));

    % Main rounds (1 -> 9)
    for roundIndex = 1:(Nr - 1)
        state = subBytes(state);
        state = shiftRows(state);
        state = mixColumns(state);
        keyStart = roundIndex * 4 + 1;
        state = addRoundKey(state, roundKeys(:, keyStart:keyStart+3));
    end

    % Final round (no MixColumns)
    state = subBytes(state);
    state = shiftRows(state);
    keyStart = Nr * 4 + 1;
    state = addRoundKey(state, roundKeys(:, keyStart:keyStart+3));

    encryptedBlock = reshape(state, 1, 16);
end


% helper functions

function out = addRoundKey(state, keyWords)
    out = bitxor(state, keyWords);
end

function out = subBytes(state)
    out = uint8(aes_sbox_lookup(double(state) + 1));
end

function out = shiftRows(state)
    out = state;
    out(2, :) = circshift(out(2, :), [0 -1]);
    out(3, :) = circshift(out(3, :), [0 -2]);
    out(4, :) = circshift(out(4, :), [0 -3]);
end

function out = mixColumns(state)
    out = zeros(4,4,'uint8');
    for col = 1:4
        s = state(:,col);
        out(1,col) = bitxor(bitxor(bitxor(xtime(s(1)), xtime(s(2),3)), s(3)), s(4));
        out(2,col) = bitxor(bitxor(bitxor(s(1), xtime(s(2))), xtime(s(3),3)), s(4));
        out(3,col) = bitxor(bitxor(bitxor(s(1), s(2)), xtime(s(3))), xtime(s(4),3));
        out(4,col) = bitxor(bitxor(bitxor(xtime(s(1),3), s(2)), s(3)), xtime(s(4)));
    end
end


function y = xtime(x, mul)
    if nargin == 1, mul = 2; end
    switch mul
        case 2
            y = aes_xtime(x);
        case 3
            y = bitxor(aes_xtime(x), x);
        otherwise
            error('Invalid multiplier');
    end
end

function out = aes_sbox_lookup(indices)
    persistent S
    if isempty(S)
        hexTable = [
            '637c777bf26b6fc53001672bfed7ab76';
            'ca82c97dfa5947f0add4a2af9ca472c0';
            'b7fd9326363ff7cc34a5e5f171d83115';
            '04c723c31896059a071280e2eb27b275';
            '09832c1a1b6e5aa0523bd6b329e32f84';
            '53d100ed20fcb15b6acbbe394a4c58cf';
            'd0efaafb434d338545f9027f503c9fa8';
            '51a3408f929d38f5bcb6da2110fff3d2';
            'cd0c13ec5f974417c4a77e3d645d1973';
            '60814fdc222a908846eeb814de5e0bdb';
            'e0323a0a4906245cc2d3ac629195e479';
            'e7c8376d8dd54ea96c56f4ea657aae08';
            'ba78252e1ca6b4c6e8dd741f4bbd8b8a';
            '703eb5664803f60e613557b986c11d9e';
            'e1f8981169d98e949b1e87e9ce5528df';
            '8ca1890dbfe6426841992d0fb054bb16'
        ];

        % Convert all 16 rows (16×32 chars) → one long hex string → bytes
        allHexChars = hexTable.';          % transpose → 32×16
        allHexChars = allHexChars(:).';    % linearise into 1×512 char vector

        bytePairs = reshape(allHexChars, 2, []).';  % 256×2
        S = uint8(hex2dec(bytePairs));             % 256×1 lookup
    end

    out = S(indices);
end



function out = aes_xtime(x)
    out = bitshift(x,1);
    if bitget(x,8)
        out = bitxor(out, 27);
    end
    out = bitand(out,255);
end
